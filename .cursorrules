# Polling App - Project Rules

## Project Overview
This is a Next.js 14 + ShadCN + Supabase polling application with App Router architecture.

## Folder Structure Rules

### Core Directories
- **`/app/polls/`** - All polling-related features and pages
  - `page.tsx` - Main polls listing page
  - `create/page.tsx` - Create new poll page
  - `[id]/page.tsx` - Individual poll view/vote page
  - `[id]/results/page.tsx` - Poll results page
- **`/app/api/`** - API routes and handlers
  - `polls/route.ts` - Poll CRUD operations
  - `votes/route.ts` - Vote submission endpoints
  - `auth/route.ts` - Authentication endpoints
- **`/components/`** - Shared UI components
  - `polls/` - Poll-specific components
  - `ui/` - ShadCN UI components
  - `forms/` - Reusable form components

### File Naming Conventions
- Components: `PascalCase.tsx` (e.g., `PollForm.tsx`, `PollList.tsx`, `VoteButton.tsx`)
- Pages: `page.tsx` (App Router convention)
- API routes: `route.ts` (App Router convention)
- Utilities: `camelCase.ts` (e.g., `pollUtils.ts`, `dateHelpers.ts`)

## Technology Stack

### Core Technologies
- **Next.js 14** with App Router
- **TypeScript** - Use everywhere, no `any` types
- **Tailwind CSS** - For styling
- **ShadCN/UI** - Primary component library
- **Supabase** - Database and authentication
- **React Hook Form** - Form state management

### Form Handling Rules
- **Always use `react-hook-form`** for form state management
- Use ShadCN UI components for form elements:
  - `Form`, `FormField`, `FormItem`, `FormLabel`, `FormControl`, `FormMessage`
  - `Input`, `Textarea`, `Select`, `Checkbox`, `RadioGroup`
  - `Button` for form submissions
- Example form structure:
```tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from '@/components/ui/form'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'

const formSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  description: z.string().optional(),
})

export function PollForm() {
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: '',
      description: '',
    },
  })

  const onSubmit = (values: z.infer<typeof formSchema>) => {
    // Handle form submission
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Poll Title</FormLabel>
              <FormControl>
                <Input placeholder="Enter poll title" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit">Create Poll</Button>
      </form>
    </Form>
  )
}
```

## Supabase Integration Rules

### Database Operations
- **Always use the Supabase client** from `/lib/supabaseClient.ts`
- Use TypeScript types for database operations
- Handle errors gracefully with try-catch blocks
- Example database operation:
```tsx
import { supabase } from '@/lib/supabaseClient'

export async function createPoll(pollData: {
  title: string
  description?: string
  options: string[]
  created_by: string
}) {
  try {
    const { data, error } = await supabase
      .from('polls')
      .insert([pollData])
      .select()
      .single()

    if (error) throw error
    return data
  } catch (error) {
    console.error('Error creating poll:', error)
    throw error
  }
}
```

### Authentication
- Use `useAuth()` hook from `/context/AuthContext.tsx`
- Protect routes with authentication checks
- Handle loading and error states

## Component Architecture Rules

### Component Structure
- Keep components small and focused (single responsibility)
- Use TypeScript interfaces for props
- Export components as default exports
- Use descriptive component names

### Component Example
```tsx
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'

interface PollCardProps {
  poll: {
    id: string
    title: string
    description?: string
    created_at: string
    vote_count: number
  }
  onVote?: (pollId: string) => void
}

export default function PollCard({ poll, onVote }: PollCardProps) {
  const [isVoting, setIsVoting] = useState(false)

  const handleVote = async () => {
    setIsVoting(true)
    try {
      await onVote?.(poll.id)
    } finally {
      setIsVoting(false)
    }
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>{poll.title}</CardTitle>
      </CardHeader>
      <CardContent>
        {poll.description && <p className="text-muted-foreground">{poll.description}</p>}
        <div className="flex justify-between items-center mt-4">
          <span className="text-sm text-muted-foreground">
            {poll.vote_count} votes
          </span>
          <Button onClick={handleVote} disabled={isVoting}>
            {isVoting ? 'Voting...' : 'Vote'}
          </Button>
        </div>
      </CardContent>
    </Card>
  )
}
```

## API Route Rules

### API Route Structure
- Use App Router API routes (`/app/api/`)
- Implement proper HTTP methods (GET, POST, PUT, DELETE)
- Use TypeScript for request/response types
- Handle errors with appropriate HTTP status codes

### API Route Example
```tsx
import { NextRequest, NextResponse } from 'next/server'
import { supabase } from '@/lib/supabaseClient'

export async function GET(request: NextRequest) {
  try {
    const { data, error } = await supabase
      .from('polls')
      .select('*')
      .order('created_at', { ascending: false })

    if (error) throw error

    return NextResponse.json({ polls: data })
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch polls' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    const { data, error } = await supabase
      .from('polls')
      .insert([body])
      .select()
      .single()

    if (error) throw error

    return NextResponse.json({ poll: data }, { status: 201 })
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create poll' },
      { status: 500 }
    )
  }
}
```

## Testing Rules

### Test Structure
- Place tests in `__tests__` folders next to the file being tested
- Use Jest for unit tests
- Mock Supabase operations
- Test component behavior, not implementation details

### Test Example
```tsx
// __tests__/PollCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import PollCard from '../PollCard'

const mockPoll = {
  id: '1',
  title: 'Test Poll',
  description: 'Test Description',
  created_at: '2023-01-01',
  vote_count: 5
}

describe('PollCard', () => {
  it('renders poll information correctly', () => {
    render(<PollCard poll={mockPoll} />)
    
    expect(screen.getByText('Test Poll')).toBeInTheDocument()
    expect(screen.getByText('Test Description')).toBeInTheDocument()
    expect(screen.getByText('5 votes')).toBeInTheDocument()
  })

  it('calls onVote when vote button is clicked', () => {
    const mockOnVote = jest.fn()
    render(<PollCard poll={mockPoll} onVote={mockOnVote} />)
    
    fireEvent.click(screen.getByText('Vote'))
    expect(mockOnVote).toHaveBeenCalledWith('1')
  })
})
```

## Code Quality Rules

### TypeScript
- Use strict TypeScript configuration
- Define interfaces for all data structures
- Use type guards for runtime type checking
- Avoid `any` types - use proper typing

### Error Handling
- Always handle errors gracefully
- Provide meaningful error messages
- Use try-catch blocks for async operations
- Log errors for debugging

### Performance
- Use React.memo for expensive components
- Implement proper loading states
- Use Suspense for code splitting
- Optimize database queries

## Styling Rules

### Tailwind CSS
- Use Tailwind utility classes
- Follow the existing design system
- Use ShadCN UI components as base
- Maintain consistent spacing and colors

### Responsive Design
- Mobile-first approach
- Use responsive breakpoints (sm, md, lg, xl)
- Test on different screen sizes

## Security Rules

### Authentication
- Always verify user authentication for protected routes
- Use Supabase RLS (Row Level Security) policies
- Validate user input on both client and server
- Sanitize data before database operations

### Data Validation
- Use Zod schemas for form validation
- Validate API request data
- Sanitize user inputs
- Implement rate limiting for API endpoints

## Development Workflow

### Git Conventions
- Use descriptive commit messages
- Create feature branches for new functionality
- Write tests before implementing features
- Review code before merging

### Code Organization
- Group related functionality together
- Use barrel exports for clean imports
- Keep utility functions in `/lib/`
- Document complex business logic

## Common Patterns

### Data Fetching
```tsx
'use client'

import { useEffect, useState } from 'react'
import { supabase } from '@/lib/supabaseClient'

export function usePolls() {
  const [polls, setPolls] = useState([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    async function fetchPolls() {
      try {
        const { data, error } = await supabase
          .from('polls')
          .select('*')
          .order('created_at', { ascending: false })

        if (error) throw error
        setPolls(data)
      } catch (err) {
        setError(err.message)
      } finally {
        setLoading(false)
      }
    }

    fetchPolls()
  }, [])

  return { polls, loading, error }
}
```

### Loading States
```tsx
import { Button } from '@/components/ui/button'
import { Loader2 } from 'lucide-react'

export function SubmitButton({ isLoading, children, ...props }) {
  return (
    <Button disabled={isLoading} {...props}>
      {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
      {children}
    </Button>
  )
}
```

Remember: Always follow these rules when generating code for this project. Focus on maintainability, type safety, and user experience.
